# ã‚‚ã†å‹•ç”»ç”Ÿæˆã§è¿·ã‚ãªã„ï¼Google DeepMind Veoã‚’TypeScriptã§å®Œå…¨åˆ¶å¾¡ã™ã‚‹æ¬¡ä¸–ä»£AIå‹•ç”»åˆ¶ä½œã‚¬ã‚¤ãƒ‰

## ã¯ã˜ã‚ã«

ã€Œãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰é«˜å“è³ªãªå‹•ç”»ã‚’ç”Ÿæˆã—ãŸã„ã€
ã€Œãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ãƒ¬ãƒ™ãƒ«ã®å‹•ç”»ç”ŸæˆAIã‚’å®Ÿè£…ã—ãŸã„ã€
ã€ŒTypeScriptã§Veo APIã‚’åŠ¹ç‡çš„ã«æ‰±ã„ãŸã„ã€

ãã‚“ãªã‚ãªãŸã®æ‚©ã¿ã€Google DeepMind Veoã§è§£æ±ºã—ã¾ã—ã‚‡ã†ï¼

2024å¹´5æœˆã«Google DeepMindã‹ã‚‰ç™ºè¡¨ã•ã‚ŒãŸVeoã¯ã€ãƒ†ã‚­ã‚¹ãƒˆãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‹ã‚‰é«˜å“è³ªãªå‹•ç”»ã‚’ç”Ÿæˆã§ãã‚‹æœ€å…ˆç«¯ã®AIãƒ¢ãƒ‡ãƒ«ã§ã™ã€‚2024å¹´12æœˆã«ã¯Veo 2ãŒã€ãã—ã¦2025å¹´ã«ã¯Veo 3ãŒãƒªãƒªãƒ¼ã‚¹ã•ã‚Œã€4Kè§£åƒåº¦ã‚„éŸ³å£°ç”Ÿæˆæ©Ÿèƒ½ã‚‚è¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚

ã“ã®è¨˜äº‹ã§ã¯ã€Veo APIã‚’TypeScriptã§å®Œå…¨åˆ¶å¾¡ã™ã‚‹å®Ÿè£…æ–¹æ³•ã‚’ã€åŸºæœ¬çš„ãªã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‹ã‚‰å®Ÿéš›ã®å‹•ç”»ç”Ÿæˆã€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¾ã§å¾¹åº•è§£èª¬ã—ã¾ã™ã€‚

## Google DeepMind Veoã¨ã¯

**ğŸ¬ é«˜å“è³ªå‹•ç”»ç”Ÿæˆ**

>* 8ç§’é–“ã®720pï¼ˆVeo 3ï¼‰/ 4Kè§£åƒåº¦ï¼ˆVeo 2ï¼‰å‹•ç”»ã‚’ç”Ÿæˆ
>* ãƒªã‚¢ãƒ«ãªç‰©ç†æ³•å‰‡ã¨æ˜ ç”»çš„ãªè¡¨ç¾ãŒå¯èƒ½
>* ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰å‹•ç”»ã€ç”»åƒã‹ã‚‰å‹•ç”»ã®ä¸¡æ–¹ã«å¯¾å¿œ

**ğŸµ ãƒã‚¤ãƒ†ã‚£ãƒ–éŸ³å£°ç”Ÿæˆï¼ˆVeo 3ï¼‰**

>* æ˜ åƒã«åŒæœŸã—ãŸéŸ³å£°ã‚’è‡ªå‹•ç”Ÿæˆ
>* åŠ¹æœéŸ³ã€BGMã€ãƒŠãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã«å¯¾å¿œ
>* ã‚»ãƒªãƒ•ã‚„ç’°å¢ƒéŸ³ã®ç´°ã‹ãªåˆ¶å¾¡ãŒå¯èƒ½

**âš¡ é«˜é€Ÿç”Ÿæˆ**

>* Veo 3ï¼š11ç§’ã€œ6åˆ†ã§ç”Ÿæˆå®Œäº†
>* Veo 3 Fastï¼šã‚ˆã‚Šé«˜é€Ÿãªè»½é‡ç‰ˆã‚‚æä¾›
>* ãƒãƒƒãƒå‡¦ç†ã«ã‚ˆã‚‹å¤§é‡ç”Ÿæˆã‚‚å¯èƒ½

| ãƒãƒ¼ã‚¸ãƒ§ãƒ³ | ãƒªãƒªãƒ¼ã‚¹ | è§£åƒåº¦ | éŸ³å£° | ç‰¹å¾´ |
|:---:|:---:|:---:|:---:|:---|
| Veo | 2024å¹´5æœˆ | 720p | âŒ | åˆæœŸç‰ˆã€åŸºæœ¬çš„ãªãƒ†ã‚­ã‚¹ãƒˆâ†’å‹•ç”» |
| Veo 2 | 2024å¹´12æœˆ | 4K | âŒ | è§£åƒåº¦å‘ä¸Šã€ç‰©ç†æ³•å‰‡ã®æ”¹å–„ |
| Veo 3 | 2025å¹´ | 720p | âœ… | éŸ³å£°ç”Ÿæˆã€SynthIDé€ã‹ã— |

## ç’°å¢ƒæ§‹ç¯‰ã¨ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

**Google Cloud Projectã®è¨­å®š**

```bash
# Google Cloud CLIã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ï¼ˆWindowsï¼‰
winget install Google.CloudSDK

# èªè¨¼è¨­å®š
gcloud auth login
gcloud config set project YOUR_PROJECT_ID

# Vertex AI APIã®æœ‰åŠ¹åŒ–
gcloud services enable aiplatform.googleapis.com
```

**Node.jsãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®åˆæœŸåŒ–**

```bash
# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
mkdir veo-typescript-app
cd veo-typescript-app
npm init -y

# TypeScriptç’°å¢ƒæ§‹ç¯‰
npm install -D typescript @types/node ts-node
npm install @google/genai dotenv
```

**tsconfig.json**

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

**.env**
```env
GOOGLE_GENAI_API_KEY=your_api_key_here
PROJECT_ID=your_project_id
LOCATION=us-central1
```

## åŸºæœ¬å®Ÿè£…ï¼šVeo TypeScriptã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ

### 1\. åŸºæœ¬ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¯ãƒ©ã‚¹

**src/veo-client.ts**
```typescript
import { GoogleGenAI, ModelPart, generateVideosResponse } from '@google/genai';
import * as fs from 'fs/promises';
import * as path from 'path';
import { config } from 'dotenv';

config();

export interface VeoConfig {
  aspectRatio?: '16:9' | '9:16';
  negativePrompt?: string;
  seed?: number;
}

export interface GenerationResult {
  videoPath: string;
  duration: number;
  metadata: {
    prompt: string;
    model: string;
    generatedAt: Date;
    config?: VeoConfig;
  };
}

export class VeoClient {
  private client: GoogleGenAI;
  private outputDir: string;

  constructor(outputDir = './generated-videos') {
    const apiKey = process.env.GOOGLE_GENAI_API_KEY;
    if (!apiKey) {
      throw new Error('GOOGLE_GENAI_API_KEY environment variable is required');
    }

    this.client = new GoogleGenAI({ 
      apiKey,
      project: process.env.PROJECT_ID,
      location: process.env.LOCATION || 'us-central1'
    });
    
    this.outputDir = outputDir;
    this.ensureOutputDirectory();
  }

  private async ensureOutputDirectory(): Promise<void> {
    try {
      await fs.mkdir(this.outputDir, { recursive: true });
    } catch (error) {
      console.error('Failed to create output directory:', error);
    }
  }

  async generateVideo(
    prompt: string, 
    config?: VeoConfig,
    model: string = 'veo-3.0-generate-preview'
  ): Promise<GenerationResult> {
    console.log(`ğŸ¬ Starting video generation with prompt: "${prompt}"`);
    
    try {
      // å‹•ç”»ç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆ
      const operation = await this.client.models.generateVideos({
        model,
        prompt,
        config: {
          aspectRatio: config?.aspectRatio || '16:9',
          negativePrompt: config?.negativePrompt,
          seed: config?.seed
        }
      });

      console.log('â³ Waiting for video generation to complete...');
      
      // ç”Ÿæˆå®Œäº†ã¾ã§å¾…æ©Ÿï¼ˆãƒãƒ¼ãƒªãƒ³ã‚°ï¼‰
      let completedOperation = operation;
      while (!completedOperation.done) {
        await this.sleep(20000); // 20ç§’å¾…æ©Ÿ
        completedOperation = await this.client.operations.get(operation);
        console.log('ğŸ“Š Generation status:', completedOperation.done ? 'Complete' : 'In Progress');
      }

      // çµæœå–å¾—ã¨ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
      const result = completedOperation.result;
      if (!result?.generated_videos?.[0]?.video) {
        throw new Error('No video generated in response');
      }

      const generatedVideo = result.generated_videos[0];
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = `veo_video_${timestamp}.mp4`;
      const videoPath = path.join(this.outputDir, filename);

      // ãƒ“ãƒ‡ã‚ªãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
      await this.client.files.download({
        file: generatedVideo.video,
        destination: videoPath
      });

      console.log(`âœ… Video generated successfully: ${videoPath}`);

      return {
        videoPath,
        duration: 8, // Veoã¯8ç§’å‹•ç”»ã‚’ç”Ÿæˆ
        metadata: {
          prompt,
          model,
          generatedAt: new Date(),
          config
        }
      };

    } catch (error) {
      console.error('âŒ Video generation failed:', error);
      throw new Error(`Video generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async generateVideoFromImage(
    prompt: string,
    imagePath: string,
    config?: VeoConfig,
    model: string = 'veo-3.0-generate-preview'
  ): Promise<GenerationResult> {
    console.log(`ğŸ–¼ï¸ Starting image-to-video generation: "${prompt}"`);
    
    try {
      // ç”»åƒã‚’èª­ã¿è¾¼ã¿
      const imageData = await fs.readFile(imagePath);
      const imagePart: ModelPart = {
        inlineData: {
          data: imageData.toString('base64'),
          mimeType: this.getMimeType(imagePath)
        }
      };

      const operation = await this.client.models.generateVideos({
        model,
        prompt,
        config: {
          aspectRatio: config?.aspectRatio || '16:9',
          negativePrompt: config?.negativePrompt,
          seed: config?.seed
        },
        contents: [
          {
            parts: [imagePart, { text: prompt }]
          }
        ]
      });

      // ä»¥é™ã®å‡¦ç†ã¯ generateVideo ã¨åŒã˜
      console.log('â³ Waiting for image-to-video generation to complete...');
      
      let completedOperation = operation;
      while (!completedOperation.done) {
        await this.sleep(20000);
        completedOperation = await this.client.operations.get(operation);
      }

      const result = completedOperation.result;
      if (!result?.generated_videos?.[0]?.video) {
        throw new Error('No video generated from image');
      }

      const generatedVideo = result.generated_videos[0];
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = `veo_image_to_video_${timestamp}.mp4`;
      const videoPath = path.join(this.outputDir, filename);

      await this.client.files.download({
        file: generatedVideo.video,
        destination: videoPath
      });

      console.log(`âœ… Image-to-video generated successfully: ${videoPath}`);

      return {
        videoPath,
        duration: 8,
        metadata: {
          prompt,
          model,
          generatedAt: new Date(),
          config
        }
      };

    } catch (error) {
      console.error('âŒ Image-to-video generation failed:', error);
      throw new Error(`Image-to-video generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private getMimeType(filePath: string): string {
    const ext = path.extname(filePath).toLowerCase();
    switch (ext) {
      case '.jpg':
      case '.jpeg':
        return 'image/jpeg';
      case '.png':
        return 'image/png';
      case '.webp':
        return 'image/webp';
      default:
        return 'image/jpeg';
    }
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### 2\. ãƒãƒƒãƒç”Ÿæˆæ©Ÿèƒ½

**src/batch-generator.ts**
```typescript
import { VeoClient, VeoConfig, GenerationResult } from './veo-client';
import * as fs from 'fs/promises';
import * as path from 'path';

export interface BatchJob {
  id: string;
  prompt: string;
  config?: VeoConfig;
  model?: string;
}

export interface BatchResult {
  jobId: string;
  success: boolean;
  result?: GenerationResult;
  error?: string;
  executionTime: number;
}

export class VeoBatchGenerator {
  private veoClient: VeoClient;
  private maxConcurrentJobs: number;

  constructor(outputDir?: string, maxConcurrentJobs = 3) {
    this.veoClient = new VeoClient(outputDir);
    this.maxConcurrentJobs = maxConcurrentJobs;
  }

  async processBatch(jobs: BatchJob[]): Promise<BatchResult[]> {
    console.log(`ğŸ”„ Starting batch processing of ${jobs.length} jobs`);
    const results: BatchResult[] = [];
    
    // ä¸¦è¡Œå®Ÿè¡Œã‚’åˆ¶é™ã—ãªãŒã‚‰å‡¦ç†
    for (let i = 0; i < jobs.length; i += this.maxConcurrentJobs) {
      const chunk = jobs.slice(i, i + this.maxConcurrentJobs);
      const chunkPromises = chunk.map(job => this.processJob(job));
      const chunkResults = await Promise.allSettled(chunkPromises);
      
      chunkResults.forEach((result, index) => {
        const job = chunk[index];
        if (result.status === 'fulfilled') {
          results.push(result.value);
        } else {
          results.push({
            jobId: job.id,
            success: false,
            error: result.reason?.message || 'Unknown error',
            executionTime: 0
          });
        }
      });
    }

    await this.generateBatchReport(results);
    return results;
  }

  private async processJob(job: BatchJob): Promise<BatchResult> {
    const startTime = Date.now();
    
    try {
      console.log(`ğŸ¬ Processing job ${job.id}: "${job.prompt}"`);
      
      const result = await this.veoClient.generateVideo(
        job.prompt,
        job.config,
        job.model
      );

      const executionTime = Date.now() - startTime;
      
      return {
        jobId: job.id,
        success: true,
        result,
        executionTime
      };

    } catch (error) {
      const executionTime = Date.now() - startTime;
      
      return {
        jobId: job.id,
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        executionTime
      };
    }
  }

  private async generateBatchReport(results: BatchResult[]): Promise<void> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const reportPath = path.join('./generated-videos', `batch-report-${timestamp}.json`);
    
    const report = {
      generatedAt: new Date().toISOString(),
      totalJobs: results.length,
      successfulJobs: results.filter(r => r.success).length,
      failedJobs: results.filter(r => !r.success).length,
      averageExecutionTime: results.reduce((sum, r) => sum + r.executionTime, 0) / results.length,
      results
    };

    await fs.writeFile(reportPath, JSON.stringify(report, null, 2));
    console.log(`ğŸ“Š Batch report generated: ${reportPath}`);
  }

  async loadJobsFromFile(filePath: string): Promise<BatchJob[]> {
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      return JSON.parse(content) as BatchJob[];
    } catch (error) {
      throw new Error(`Failed to load jobs from ${filePath}: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}
```

## å®Ÿç”¨çš„ãªå®Ÿè£…ä¾‹

### 1\. ã‚·ãƒ³ãƒ—ãƒ«ãªå‹•ç”»ç”Ÿæˆ

**src/examples/basic-generation.ts**
```typescript
import { VeoClient } from '../veo-client';

async function basicExample() {
  const veoClient = new VeoClient();

  try {
    // ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ†ã‚­ã‚¹ãƒˆâ†’å‹•ç”»ç”Ÿæˆ
    const result = await veoClient.generateVideo(
      "A majestic golden retriever playing in a field of sunflowers at sunset, cinematic shot with shallow depth of field"
    );

    console.log('ç”Ÿæˆã•ã‚ŒãŸå‹•ç”»:', result.videoPath);
    console.log('ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿:', result.metadata);

  } catch (error) {
    console.error('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error);
  }
}

basicExample();
```

### 2\. é«˜åº¦ãªè¨­å®šã§ã®å‹•ç”»ç”Ÿæˆ

**src/examples/advanced-generation.ts**
```typescript
import { VeoClient, VeoConfig } from '../veo-client';

async function advancedExample() {
  const veoClient = new VeoClient('./my-videos');

  // é«˜åº¦ãªè¨­å®š
  const config: VeoConfig = {
    aspectRatio: '16:9',
    negativePrompt: 'blurry, low quality, distorted, cartoon style',
    seed: 12345 // å†ç¾å¯èƒ½ãªç”Ÿæˆã®ãŸã‚
  };

  try {
    // è¤‡æ•°ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç”Ÿæˆ
    const prompts = [
      "A serene Japanese garden with cherry blossoms falling, peaceful morning light",
      "A bustling Tokyo street at night with neon signs reflecting on wet pavement",
      "A traditional Japanese tea ceremony in a wooden house, soft natural lighting"
    ];

    for (const prompt of prompts) {
      console.log(`\nğŸ¬ Generating: ${prompt}`);
      
      const result = await veoClient.generateVideo(prompt, config);
      
      console.log(`âœ… Complete: ${result.videoPath}`);
      console.log(`ğŸ“Š Generated at: ${result.metadata.generatedAt}`);
    }

  } catch (error) {
    console.error('âŒ Generation failed:', error);
  }
}

advancedExample();
```

### 3\. ç”»åƒã‹ã‚‰ãƒ“ãƒ‡ã‚ªç”Ÿæˆ

**src/examples/image-to-video.ts**
```typescript
import { VeoClient } from '../veo-client';

async function imageToVideoExample() {
  const veoClient = new VeoClient();

  try {
    // ç”»åƒã‚’å‹•ç”»ã«å¤‰æ›
    const result = await veoClient.generateVideoFromImage(
      "Make this image come to life with gentle movement and natural lighting changes",
      "./source-images/landscape.jpg",
      {
        aspectRatio: '16:9',
        negativePrompt: 'rapid motion, shaking, distortion'
      }
    );

    console.log('ç”»åƒã‹ã‚‰ç”Ÿæˆã•ã‚ŒãŸå‹•ç”»:', result.videoPath);

  } catch (error) {
    console.error('ç”»åƒâ†’å‹•ç”»å¤‰æ›ã‚¨ãƒ©ãƒ¼:', error);
  }
}

imageToVideoExample();
```

### 4\. ãƒãƒƒãƒå‡¦ç†ã®å®Ÿè£…

**src/examples/batch-processing.ts**
```typescript
import { VeoBatchGenerator, BatchJob } from '../batch-generator';

async function batchProcessingExample() {
  const batchGenerator = new VeoBatchGenerator('./batch-videos', 2); // åŒæ™‚å®Ÿè¡Œæ•°2

  // ãƒãƒƒãƒã‚¸ãƒ§ãƒ–ã®å®šç¾©
  const jobs: BatchJob[] = [
    {
      id: 'nature-001',
      prompt: "A peaceful mountain lake reflecting snow-capped peaks at sunrise",
      config: { aspectRatio: '16:9' }
    },
    {
      id: 'urban-001',
      prompt: "A busy city intersection with people crossing, birds eye view",
      config: { aspectRatio: '16:9', negativePrompt: 'cars, traffic' }
    },
    {
      id: 'animal-001',
      prompt: "A family of deer grazing in a meadow, soft morning light",
      config: { aspectRatio: '9:16' }
    }
  ];

  try {
    console.log('ğŸ”„ Starting batch video generation...');
    const results = await batchGenerator.processBatch(jobs);

    // çµæœã®è¡¨ç¤º
    results.forEach(result => {
      if (result.success) {
        console.log(`âœ… ${result.jobId}: Success (${result.executionTime}ms)`);
        console.log(`   Video: ${result.result?.videoPath}`);
      } else {
        console.log(`âŒ ${result.jobId}: Failed - ${result.error}`);
      }
    });

  } catch (error) {
    console.error('ãƒãƒƒãƒå‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
  }
}

batchProcessingExample();
```

## ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°

### 1\. åŒ…æ‹¬çš„ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

**src/error-handler.ts**
```typescript
export enum VeoErrorType {
  AUTHENTICATION = 'AUTHENTICATION',
  QUOTA_EXCEEDED = 'QUOTA_EXCEEDED',
  INVALID_PROMPT = 'INVALID_PROMPT',
  GENERATION_FAILED = 'GENERATION_FAILED',
  FILE_OPERATION = 'FILE_OPERATION',
  NETWORK = 'NETWORK'
}

export class VeoError extends Error {
  constructor(
    public type: VeoErrorType,
    message: string,
    public originalError?: Error,
    public context?: Record<string, any>
  ) {
    super(message);
    this.name = 'VeoError';
  }
}

export function handleVeoError(error: unknown, context?: Record<string, any>): VeoError {
  if (error instanceof VeoError) {
    return error;
  }

  if (error instanceof Error) {
    // Google APIå›ºæœ‰ã®ã‚¨ãƒ©ãƒ¼ã‚’åˆ¤å®š
    if (error.message.includes('authentication')) {
      return new VeoError(
        VeoErrorType.AUTHENTICATION,
        'Authentication failed. Check your API key and permissions.',
        error,
        context
      );
    }

    if (error.message.includes('quota') || error.message.includes('rate limit')) {
      return new VeoError(
        VeoErrorType.QUOTA_EXCEEDED,
        'API quota exceeded. Please wait before retrying.',
        error,
        context
      );
    }

    if (error.message.includes('prompt') || error.message.includes('invalid')) {
      return new VeoError(
        VeoErrorType.INVALID_PROMPT,
        'Invalid prompt or parameters provided.',
        error,
        context
      );
    }

    if (error.message.includes('ENOENT') || error.message.includes('file')) {
      return new VeoError(
        VeoErrorType.FILE_OPERATION,
        'File operation failed. Check file paths and permissions.',
        error,
        context
      );
    }

    if (error.message.includes('network') || error.message.includes('timeout')) {
      return new VeoError(
        VeoErrorType.NETWORK,
        'Network error occurred. Check your connection and try again.',
        error,
        context
      );
    }

    return new VeoError(
      VeoErrorType.GENERATION_FAILED,
      `Video generation failed: ${error.message}`,
      error,
      context
    );
  }

  return new VeoError(
    VeoErrorType.GENERATION_FAILED,
    'An unknown error occurred during video generation.',
    undefined,
    context
  );
}
```

### 2\. ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ä»˜ãã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ

**src/resilient-veo-client.ts**
```typescript
import { VeoClient, VeoConfig, GenerationResult } from './veo-client';
import { handleVeoError, VeoError, VeoErrorType } from './error-handler';

export interface RetryConfig {
  maxRetries: number;
  baseDelay: number;
  maxDelay: number;
  retryableErrors: VeoErrorType[];
}

export class ResilientVeoClient extends VeoClient {
  private retryConfig: RetryConfig;

  constructor(
    outputDir?: string,
    retryConfig: Partial<RetryConfig> = {}
  ) {
    super(outputDir);
    
    this.retryConfig = {
      maxRetries: 3,
      baseDelay: 1000,
      maxDelay: 30000,
      retryableErrors: [
        VeoErrorType.NETWORK,
        VeoErrorType.QUOTA_EXCEEDED,
        VeoErrorType.GENERATION_FAILED
      ],
      ...retryConfig
    };
  }

  async generateVideoWithRetry(
    prompt: string,
    config?: VeoConfig,
    model?: string
  ): Promise<GenerationResult> {
    let lastError: VeoError | null = null;

    for (let attempt = 0; attempt <= this.retryConfig.maxRetries; attempt++) {
      try {
        console.log(`ğŸ¬ Attempt ${attempt + 1}/${this.retryConfig.maxRetries + 1}: "${prompt}"`);
        
        return await this.generateVideo(prompt, config, model);

      } catch (error) {
        lastError = handleVeoError(error, { 
          attempt, 
          prompt: prompt.substring(0, 100),
          model 
        });

        console.warn(`âš ï¸ Attempt ${attempt + 1} failed:`, lastError.message);

        // æœ€å¾Œã®è©¦è¡Œã®å ´åˆã¯ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹
        if (attempt === this.retryConfig.maxRetries) {
          break;
        }

        // ãƒªãƒˆãƒ©ã‚¤å¯èƒ½ãªã‚¨ãƒ©ãƒ¼ã‹ãƒã‚§ãƒƒã‚¯
        if (!this.retryConfig.retryableErrors.includes(lastError.type)) {
          console.error(`âŒ Non-retryable error: ${lastError.type}`);
          break;
        }

        // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã§å¾…æ©Ÿ
        const delay = Math.min(
          this.retryConfig.baseDelay * Math.pow(2, attempt),
          this.retryConfig.maxDelay
        );
        
        console.log(`â±ï¸ Retrying in ${delay}ms...`);
        await this.sleep(delay);
      }
    }

    throw lastError || new VeoError(
      VeoErrorType.GENERATION_FAILED,
      'Video generation failed after all retries'
    );
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### 1\. ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæœ€é©åŒ–

**è‰¯ã„ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®ä¾‹ï¼š**
```typescript
const optimizedPrompts = {
  // âŒ æ‚ªã„ä¾‹ï¼šæ›–æ˜§ã§ä¸å…·ä½“
  bad: "A dog playing",
  
  // âœ… è‰¯ã„ä¾‹ï¼šå…·ä½“çš„ã§è©³ç´°
  good: "A golden retriever playing fetch in a sunny park, slow motion shot with cinematic lighting, shallow depth of field, professional cinematography",
  
  // âœ… éŸ³å£°è¾¼ã¿ã®ä¾‹ï¼ˆVeo 3ï¼‰
  withAudio: "A jazz pianist performing in a dimly lit club, camera slowly zooming in, soft piano melody with ambient club sounds, warm golden lighting"
};
```

### 2\. ã‚³ã‚¹ãƒˆæœ€é©åŒ–

**src/cost-optimizer.ts**
```typescript
export class VeoCostOptimizer {
  private readonly VEO_3_COST_PER_SECOND = 0.75; // $0.75 per second
  
  calculateCost(videoDurationSeconds: number, videoCount: number): number {
    return videoDurationSeconds * videoCount * this.VEO_3_COST_PER_SECOND;
  }

  estimateBatchCost(prompts: string[]): number {
    // Veoã¯8ç§’å‹•ç”»ã‚’ç”Ÿæˆ
    return this.calculateCost(8, prompts.length);
  }

  suggestOptimization(estimatedCost: number): string[] {
    const suggestions: string[] = [];
    
    if (estimatedCost > 50) {
      suggestions.push('ğŸ’° Consider using Veo 3 Fast for lower costs');
      suggestions.push('ğŸ¯ Test prompts with single generation before batch processing');
    }
    
    if (estimatedCost > 100) {
      suggestions.push('â³ Process videos in smaller batches to manage costs');
      suggestions.push('ğŸ”„ Implement caching to avoid regenerating similar content');
    }

    return suggestions;
  }
}
```

### 3\. ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ©Ÿèƒ½

**src/video-cache.ts**
```typescript
import * as crypto from 'crypto';
import * as fs from 'fs/promises';
import * as path from 'path';
import { GenerationResult, VeoConfig } from './veo-client';

interface CacheEntry {
  prompt: string;
  config: VeoConfig;
  result: GenerationResult;
  cachedAt: Date;
}

export class VideoCache {
  private cacheDir: string;
  private maxCacheAge: number; // ãƒŸãƒªç§’

  constructor(cacheDir = './video-cache', maxCacheAgeHours = 24) {
    this.cacheDir = cacheDir;
    this.maxCacheAge = maxCacheAgeHours * 60 * 60 * 1000;
    this.ensureCacheDirectory();
  }

  private async ensureCacheDirectory(): Promise<void> {
    try {
      await fs.mkdir(this.cacheDir, { recursive: true });
    } catch (error) {
      console.error('Failed to create cache directory:', error);
    }
  }

  private generateCacheKey(prompt: string, config?: VeoConfig): string {
    const content = JSON.stringify({ prompt, config });
    return crypto.createHash('md5').update(content).digest('hex');
  }

  async get(prompt: string, config?: VeoConfig): Promise<GenerationResult | null> {
    const cacheKey = this.generateCacheKey(prompt, config);
    const cacheFile = path.join(this.cacheDir, `${cacheKey}.json`);

    try {
      const cacheData = await fs.readFile(cacheFile, 'utf-8');
      const entry: CacheEntry = JSON.parse(cacheData);

      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®æœ‰åŠ¹æœŸé™ã‚’ãƒã‚§ãƒƒã‚¯
      const age = Date.now() - new Date(entry.cachedAt).getTime();
      if (age > this.maxCacheAge) {
        await this.delete(cacheKey);
        return null;
      }

      // ãƒ“ãƒ‡ã‚ªãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
      try {
        await fs.access(entry.result.videoPath);
        console.log(`ğŸ“¦ Cache hit for prompt: ${prompt.substring(0, 50)}...`);
        return entry.result;
      } catch {
        // ãƒ“ãƒ‡ã‚ªãƒ•ã‚¡ã‚¤ãƒ«ãŒå‰Šé™¤ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç„¡åŠ¹åŒ–
        await this.delete(cacheKey);
        return null;
      }

    } catch {
      return null;
    }
  }

  async set(prompt: string, config: VeoConfig | undefined, result: GenerationResult): Promise<void> {
    const cacheKey = this.generateCacheKey(prompt, config);
    const cacheFile = path.join(this.cacheDir, `${cacheKey}.json`);

    const entry: CacheEntry = {
      prompt,
      config: config || {},
      result,
      cachedAt: new Date()
    };

    try {
      await fs.writeFile(cacheFile, JSON.stringify(entry, null, 2));
      console.log(`ğŸ’¾ Cached result for prompt: ${prompt.substring(0, 50)}...`);
    } catch (error) {
      console.error('Failed to write cache:', error);
    }
  }

  private async delete(cacheKey: string): Promise<void> {
    const cacheFile = path.join(this.cacheDir, `${cacheKey}.json`);
    try {
      await fs.unlink(cacheFile);
    } catch {
      // ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ç„¡è¦–
    }
  }

  async cleanup(): Promise<void> {
    try {
      const files = await fs.readdir(this.cacheDir);
      const now = Date.now();

      for (const file of files) {
        if (!file.endsWith('.json')) continue;

        const filePath = path.join(this.cacheDir, file);
        try {
          const content = await fs.readFile(filePath, 'utf-8');
          const entry: CacheEntry = JSON.parse(content);
          
          const age = now - new Date(entry.cachedAt).getTime();
          if (age > this.maxCacheAge) {
            await fs.unlink(filePath);
            console.log(`ğŸ—‘ï¸ Cleaned up expired cache: ${file}`);
          }
        } catch {
          // å£Šã‚ŒãŸã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤
          await fs.unlink(filePath);
        }
      }
    } catch (error) {
      console.error('Cache cleanup failed:', error);
    }
  }
}
```

## å®Ÿç”¨çš„ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ä¾‹

### 1\. CLI ãƒ„ãƒ¼ãƒ«

**src/cli/veo-cli.ts**
```typescript
#!/usr/bin/env node
import { Command } from 'commander';
import { VeoClient } from '../veo-client';
import { VeoBatchGenerator } from '../batch-generator';
import { VeoCostOptimizer } from '../cost-optimizer';
import { VideoCache } from '../video-cache';

const program = new Command();

program
  .name('veo-cli')
  .description('Google DeepMind Veo video generation CLI')
  .version('1.0.0');

// å˜ä¸€å‹•ç”»ç”Ÿæˆã‚³ãƒãƒ³ãƒ‰
program
  .command('generate')
  .description('Generate a single video from text prompt')
  .argument('<prompt>', 'Text prompt for video generation')
  .option('-o, --output <dir>', 'Output directory', './generated-videos')
  .option('-r, --ratio <ratio>', 'Aspect ratio (16:9 or 9:16)', '16:9')
  .option('-n, --negative <prompt>', 'Negative prompt')
  .option('-m, --model <model>', 'Model to use', 'veo-3.0-generate-preview')
  .option('--no-cache', 'Disable cache')
  .action(async (prompt, options) => {
    try {
      console.log('ğŸ¬ Starting video generation...');
      
      const cache = options.cache ? new VideoCache() : null;
      
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
      if (cache) {
        const cached = await cache.get(prompt, {
          aspectRatio: options.ratio,
          negativePrompt: options.negative
        });
        if (cached) {
          console.log('ğŸ“¦ Using cached result:', cached.videoPath);
          return;
        }
      }

      const veoClient = new VeoClient(options.output);
      const result = await veoClient.generateVideo(prompt, {
        aspectRatio: options.ratio,
        negativePrompt: options.negative
      }, options.model);

      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
      if (cache) {
        await cache.set(prompt, {
          aspectRatio: options.ratio,
          negativePrompt: options.negative
        }, result);
      }

      console.log('âœ… Generation completed!');
      console.log('ğŸ“ Video path:', result.videoPath);
      
      // ã‚³ã‚¹ãƒˆè¨ˆç®—
      const costOptimizer = new VeoCostOptimizer();
      const cost = costOptimizer.calculateCost(8, 1);
      console.log('ğŸ’° Estimated cost:', `$${cost.toFixed(2)}`);

    } catch (error) {
      console.error('âŒ Generation failed:', error);
      process.exit(1);
    }
  });

// ãƒãƒƒãƒå‡¦ç†ã‚³ãƒãƒ³ãƒ‰
program
  .command('batch')
  .description('Generate multiple videos from job file')
  .argument('<jobFile>', 'JSON file containing batch jobs')
  .option('-o, --output <dir>', 'Output directory', './batch-videos')
  .option('-c, --concurrent <num>', 'Max concurrent jobs', '2')
  .action(async (jobFile, options) => {
    try {
      console.log('ğŸ”„ Starting batch processing...');
      
      const batchGenerator = new VeoBatchGenerator(
        options.output,
        parseInt(options.concurrent)
      );

      const jobs = await batchGenerator.loadJobsFromFile(jobFile);
      
      // ã‚³ã‚¹ãƒˆè¦‹ç©ã‚‚ã‚Š
      const costOptimizer = new VeoCostOptimizer();
      const estimatedCost = costOptimizer.estimateBatchCost(
        jobs.map(job => job.prompt)
      );
      
      console.log(`ğŸ’° Estimated total cost: $${estimatedCost.toFixed(2)}`);
      
      const suggestions = costOptimizer.suggestOptimization(estimatedCost);
      if (suggestions.length > 0) {
        console.log('ğŸ’¡ Cost optimization suggestions:');
        suggestions.forEach(suggestion => console.log(`   ${suggestion}`));
      }

      const results = await batchGenerator.processBatch(jobs);
      
      const successful = results.filter(r => r.success).length;
      console.log(`âœ… Batch completed: ${successful}/${results.length} successful`);

    } catch (error) {
      console.error('âŒ Batch processing failed:', error);
      process.exit(1);
    }
  });

program.parse();
```

### 2\. ã‚µãƒ³ãƒ—ãƒ«ãƒãƒƒãƒã‚¸ãƒ§ãƒ–ãƒ•ã‚¡ã‚¤ãƒ«

**batch-jobs.json**
```json
[
  {
    "id": "nature-sunrise",
    "prompt": "A serene mountain landscape at sunrise, golden light illuminating snow-capped peaks, misty valleys below, cinematic wide shot",
    "config": {
      "aspectRatio": "16:9",
      "negativePrompt": "people, buildings, text, watermarks"
    }
  },
  {
    "id": "city-timelapse",
    "prompt": "Tokyo cityscape time-lapse at night, bustling streets with light trails, neon signs reflecting on wet pavement, urban energy",
    "config": {
      "aspectRatio": "16:9",
      "negativePrompt": "daytime, static, blurry"
    }
  },
  {
    "id": "ocean-waves",
    "prompt": "Powerful ocean waves crashing against rocky cliffs, dramatic spray and foam, overcast sky with dramatic lighting",
    "config": {
      "aspectRatio": "9:16",
      "negativePrompt": "calm, peaceful, sunny"
    }
  }
]
```

### 3\. package.json ã‚¹ã‚¯ãƒªãƒ—ãƒˆè¨­å®š

**package.json**
```json
{
  "name": "veo-typescript-app",
  "version": "1.0.0",
  "description": "Google DeepMind Veo TypeScript implementation",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "ts-node src/index.ts",
    "generate": "ts-node src/cli/veo-cli.ts generate",
    "batch": "ts-node src/cli/veo-cli.ts batch",
    "cache:cleanup": "ts-node -e \"import('./src/video-cache').then(m => new m.VideoCache().cleanup())\"",
    "cost:estimate": "ts-node src/examples/cost-estimation.ts"
  },
  "dependencies": {
    "@google/genai": "^0.3.0",
    "commander": "^11.1.0",
    "dotenv": "^16.3.0"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "ts-node": "^10.9.0",
    "typescript": "^5.3.0"
  }
}
```

## ã¾ã¨ã‚

Google DeepMind Veoã‚’TypeScriptã§å®Œå…¨åˆ¶å¾¡ã™ã‚‹å®Ÿè£…æ–¹æ³•ã‚’ã”ç´¹ä»‹ã—ã¾ã—ãŸã€‚

**ã“ã®è¨˜äº‹ã§å­¦ã‚“ã ã“ã¨ï¼š**

>* Veo APIã®åŸºæœ¬çš„ãªä½¿ã„æ–¹ã¨TypeScriptå®Ÿè£…
>* ç”»åƒã‹ã‚‰ãƒ“ãƒ‡ã‚ªã¸ã®å¤‰æ›æ©Ÿèƒ½
>* ãƒãƒƒãƒå‡¦ç†ã¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
>* ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ©Ÿèƒ½
>* å®Ÿç”¨çš„ãªCLIãƒ„ãƒ¼ãƒ«ã®æ§‹ç¯‰

**æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ï¼š**

>1\. æœ¬è¨˜äº‹ã®ã‚³ãƒ¼ãƒ‰ã‚’å‚è€ƒã«åŸºæœ¬å®Ÿè£…ã‚’è©¦ã—ã¦ã¿ã¦ãã ã•ã„
>2\. ç‹¬è‡ªã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæœ€é©åŒ–ã‚’å®Ÿé¨“ã—ã¦ã¿ã¦ãã ã•ã„  
>3\. ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ç’°å¢ƒã§ã®ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°æ©Ÿèƒ½ã‚’è¿½åŠ ã—ã¦ã¿ã¦ãã ã•ã„

TypeScriptã§Veoã‚’ä½¿ã„ã“ãªã™ã“ã¨ã§ã€é«˜å“è³ªãªå‹•ç”»ç”Ÿæˆã‚’è‡ªå‹•åŒ–ã—ã€åŠ¹ç‡çš„ãªã‚³ãƒ³ãƒ†ãƒ³ãƒ„åˆ¶ä½œç’°å¢ƒã‚’æ§‹ç¯‰ã§ãã¾ã™ã­ã€‚Veoã®APIã‚’æ´»ç”¨ã—ã¦ã€ã‚ãªãŸã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«é©æ–°çš„ãªå‹•ç”»ç”Ÿæˆæ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã¦ã¿ã¦ãã ã•ã„ï¼